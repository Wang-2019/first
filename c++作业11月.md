# 9.25
  如果elem1==elem2，则函数不删除任何元素
  如果elem2是尾后迭代器，则从elem1开始，删除之后的所有元素（包括elem1）
  如果elem1和elem2均为尾后迭代器，则不删除元素
# 9.43
  ```C++
  #include <string>
#include <iostream>

using namespace std;

void p(string &s, const string &oldVal, const string &newVal)
{
	auto iter = s.begin();

	while(iter != s.end())
	{
		if(oldVal == string(iter, iter+oldVal.size()))
		{
			iter = s.erase(iter, iter+oldVal.size());
			iter = s.insert(iter, newVal.begin(), newVal.end());
			iter += newVal.size();
		}else
			++iter;
	}
}

int main()
{
	string s("tho thru");
	p(s, "tho", "though");
	cout << s << endl;
	p(s, "thru", "through");
	cout << s << endl;
	return 0;
}

  ```
# 9.52
  ```C++  
  #include <iostream>
#include <stack>
using namespace std;
 
int main()
{
    const string expr = "a()a(aaa(aaa(a)))aa()";
    const char placehold = '#';
    int num = 0; 
    stack<char> stk;
    for (auto c : expr)
    {
        stk.push(c);
        if (c == '(')
            ++num;
        if (num && c == ')')
        {
            while (stk.top() != '(')
                stk.pop();
            stk.pop();
            stk.push(placehold);
            --num;
        }
    }
    string s;
    while(!stk.empty())
    {
        s.insert(s.begin(),stk.top());
        stk.pop();
    }
    cout << s << endl;
    return 0;
}
  ```
# 10.3
```C++
#include<bits/stdc++.h>
//using namespace std;
 
int main()
{
	std::vector<int> vec;
	int t=10;
	int a;
	while(t--){
		std::cin>>a;
		vec.push_back(a);
	}
	std::cout<<"元素之和为："<<accumulate(vec.cbegin(),vec.cend(),0);
	return 0;
}
```
# 10.15
```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
	int a=10,b;
	auto f=[a](const int &b){
		cout<<a+b<<endl;
	};
	f(2);
	return 0;
}
```
# 10.34
```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
	vector<int> vec={1,2,3,4,5,6,7,8,9};
	for(auto it=vec.rbegin();it!=vec.rend();it++)
	{
		cout<<*it<<endl;
	}
	return 0;
}
```
# 10.42
```C++
#include<bits/stdc++.h>
using namespace std;

void elimDups(list<string> &words){
	words.sort();
	words.unique();
}

int main(){
	list<string> words={"sadf","aefaef","aewf","dvfhy","aa","aa"};
	elimDups(words);
	for(auto it=words.begin();it!=words.end();it++) cout<<*it<<endl;
	return 0;
}
```
# 11.12
```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
	vector<pair<string,int>> vec(10);
	string str;
	int a;
	for(int i=0;i<10;i++){
		cin>>str>>a;
		vec[i].first=str;
		vec[i].second=a;
	}
	cout<<"vec中的元素有："<<endl;
	for(auto it=vec.begin();it!=vec.end();++it) cout<<it->first<<' '<<it->second<<endl;
	return 0;
}
```
# 11.17
	(1)合法
	(2)不合法，set中没有push_back
	(3)合法
	(4)合法
# 11.38
(1)
```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
	unordered_map<string,size_t> word_count;
	string word;
	while(cin >> word){
		++word_count[word];
	}
	for(const auto &w : word_count){
		cout<<w.first<<" occurs "<<w.second<<((w.second>1)?"times":"time")<<endl;
	}
	return 0;
} 
```
(2)
```C++
#include <unordered_map>
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>

using namespace std;

unordered_map<string, string> buildMap(ifstream &map_file)
{
	unordered_map<string, string> trans_map;
	string key;
	string value;
	while(map_file >> key && getline(map_file, value))
		if(value.size() > 1)
			trans_map[key] = value.substr(1);
		else
			throw runtime_error("no rule for " + key);
	return trans_map;
}

const string &transform(const string &s, const unordered_map<string, string> &m)
{
	auto map_it = m.find(s);
	if(map_it != m.cend())
		return map_it->second;
	else
		return s;
}

void word_tranform(ifstream &map_file, ifstream &input)
{
	auto trans_map = buildMap(map_file);
	string text;
	while(getline(input, text))
	{
		istringstream stream(text);
		string word;
		bool firstword = true;
		while(stream >> word)
		{
			if(firstword)
				firstword = false;
			else
				cout << " ";
			cout << transform(word, trans_map);
		}
		cout << endl;
	}
}

int main()
{
	ifstream map_file("map_file1.txt"), input("input1.txt");
	word_tranform(map_file, input);

	return 0;
}

```
# 13.12
	执行三次,分别是accum，item1与item2
# 13.46
	（1） 右值引用，函数返回值为一个临时值；
	（2） 左值引用，vi[0]属于变量；
	（3） 左值引用，r1属于变量；
	（4） 右值引用，表达式属于临时值；
# 13.49
```C++
#ifndef STRVEC_H
#define STRVEC_H
#include<string>
#include<iostream>
#include<memory>
#include
class strvec {
public:
    strvec():elements(nullptr), first_free(nullptr), cap(nullptr) {}
    strvec(strvec &&s) noexcept:elements(s.elements), first_free(s.first_free), cap(s.cap) 
                               {s.elements = s.first_free = s.cap = nullptr;}
    strvec(const strvec &);
    strvec &operator=(const strvec&);
    ~strvec();
    void push_back(const std::string&);
    size_t size() const { return first_free - elements; }
    size_t capacity() const { return cap - elements; }
    std::string *begin() const { return elements; }
    std::string *end() const { return first_free; }
private:
    std::string *elements;
    std::string *first_free
    std::string *cap;
    static std::allocator<std::string> alloc;
    void chk_n_alloc() { if (size() == capacity()) reallocate(); }
    std::pair<std::string*, std::string*> alloc_n_copy(const std::string *b, const std::string *c) {
        auto data = alloc.allocate(c - b);
        return (data, uninitialized_copy(b, c, data));
    }
    void free();
    void reallocate();
}
void strvec::push_back(const std::string &s) {
    chk_n_alloc();
    alloc.construct(first_free++, s);
}
void strvec::free() {
    if (elements) {
        for (auto p = first_free; p != elements; )
            alloc.destroy(--p);
    }
}
strvec::strvec(const strvec &s) {
    auto newdata = alloc_n_copy(s.begin(), s.end());
    elements = newdata.first;
    first_free = cap = newdata.second;
}
strvec::~strvec() {
    free();
}
strvec &strvec::operator=(const strvec &rhs) {
    auto data = alloc_n_copy(rhs.begin(), rhs.end());
    free();
    elements = newdata.first;
    first_free = cap = newdata.second;
    return *this;
}
void strvec::reallocate() {
    auto newcapacity = size() ? 2 * size() : 1;
    auto newdata = alloc.allocate(newcapacity);
    auto dest = newdata;
    auto elem = elements;
    for (size_t i = 0; i != size(); i++) {
        alloc.construct(dest++, std::move(*elem++));
    }
    free();
    elements = newdata;
    first_free = dest;
    cap = elements + newcapacity;
}
```

# 14.3
	(a)string
	(b)string
	(c)vector
	(d)string
# 14.20
```C++
#加法定义
Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum;
    sum.units_sold = lhs.units_sold + rhs.units_sold;
    sum.revenue = lhs.revenue + rhs.revenue;
    return sum;
}
#复合赋值运算
Sales_data& Sales_data::operator+=(const Sales_data &rhs)
{
    Sales_data old_data = *this;
    *this = old_data + rhs;
    return *this;
}

```
# 14.38
```C++
#include <string>
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>

class CompareString{
public:
	CompareString(size_t n): sz(n){}
	bool operator()(const std::string &s) const{
		return sz == s.size();
	}
private:
	size_t sz;
};

int main()
{
	std::ifstream ifs("c++.txt");
    std::vector<std::string> vs;
    for(std::string curr; ifs >> curr; vs.push_back(curr));
    for(int i = 1, n = 0; i <= 10; i++)
    {
    	for(auto iter = vs.begin(); iter != vs.end(); )
    	{
    		iter = std::find_if(iter+1, vs.end(), CompareString(i));
    		if(iter != vs.end()) n++;
    	}
    	std::cout << "长度为" << i << "的单词有" << n <<"个"<< std::endl;
    	n = 0;
    }
	return 0;
}
```
# 14.52
	1)ld = si + ld 使用的是LongDouble operator+(LongDouble&, double)
	2)ld = ld + si 使用的是LongDouble operator(const SmallInt&)
# 15.12
	没必要，使用final之后则之后不能进行其他覆盖该函数的操作，使用override是覆盖了从前一个函数继承过来的虚函数，两者不是必须同时存在
# 15.16
```C++
class new_quote : public Disc_quote {
public:
    new_quote();
    new_quote(const std::string &book, double price, std::size_t qty, double disc) : Disc_quote(book, price, qty, disc) {}
    double net_price(std::size_t) const override {
        if (n > quantity) {
	    return quantity * (1 - discount) * price + (n - quantity) * price; 
	}
        else {
	    return n * price;
	}
    
    }

};
```
# 15.30
```C++
class basket {
public:
    void add_item(const std::shared_ptr<Quote> &sale) {
        items.insert(sale);
    }
    void add_item(const Quote& sale) {
        items.insert(std::shared_ptr<Quote>(sale.clone()));
    }
    void add_item(Quote&& sale) {
        items.insert(std::shared_ptr<Quote>(std::move(sale).clone()));
    }
    double total_receipt(std::ostream &os) const {
        double sum = 0.0;
	for (auto iter = items.cbegin(); iter != items.cend(); iter = items.upper_bound(*iter)) {
	    sum += print_total(os, **iter, item.count(*iter));
	}
	os << sum << std::endl;
	return sum;
    }
private:
    static bool cmp(const std::shared_ptr<Quote> &lhs, const std::shared_ptr<Quote> &rhs) {
        return lhs->isbn() < rhs.isbn();
    }
    std::multiset<std::shared_ptr<Quote>, decltype(cmp)*> items { cmp };
};
```
