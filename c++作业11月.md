# 9.25
  如果elem1==elem2，则函数不删除任何元素
  如果elem2是尾后迭代器，则从elem1开始，删除之后的所有元素（包括elem1）
  如果elem1和elem2均为尾后迭代器，则不删除元素
# 9.43
  ```C++
  #include <string>
#include <iostream>

using namespace std;

void p(string &s, const string &oldVal, const string &newVal)
{
	auto iter = s.begin();

	while(iter != s.end())
	{
		if(oldVal == string(iter, iter+oldVal.size()))
		{
			iter = s.erase(iter, iter+oldVal.size());
			iter = s.insert(iter, newVal.begin(), newVal.end());
			iter += newVal.size();
		}else
			++iter;
	}
}

int main()
{
	string s("tho thru");
	p(s, "tho", "though");
	cout << s << endl;
	p(s, "thru", "through");
	cout << s << endl;
	return 0;
}

  ```
# 9.52
  ```C++  
  #include <iostream>
#include <stack>
using namespace std;
 
int main()
{
    const string expr = "a()a(aaa(aaa(a)))aa()";
    const char placehold = '#';
    int num = 0; 
    stack<char> stk;
    for (auto c : expr)
    {
        stk.push(c);
        if (c == '(')
            ++num;
        if (num && c == ')')
        {
            while (stk.top() != '(')
                stk.pop();
            stk.pop();
            stk.push(placehold);
            --num;
        }
    }
    string s;
    while(!stk.empty())
    {
        s.insert(s.begin(),stk.top());
        stk.pop();
    }
    cout << s << endl;
    return 0;
}
  ```
# 10.3
```
#include<bits/stdc++.h>
//using namespace std;
 
int main()
{
	std::vector<int> vec;
	int t=10;
	int a;
	while(t--){
		std::cin>>a;
		vec.push_back(a);
	}
	std::cout<<"元素之和为："<<accumulate(vec.cbegin(),vec.cend(),0);
	return 0;
}
```
# 10.15
```
#include<bits/stdc++.h>
using namespace std;

int main(){
	int a=10,b;
	auto f=[a](const int &b){
		cout<<a+b<<endl;
	};
	f(2);
	return 0;
}
```
# 10.34
```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
	vector<int> vec={1,2,3,4,5,6,7,8,9};
	for(auto it=vec.rbegin();it!=vec.rend();it++)
	{
		cout<<*it<<endl;
	}
	return 0;
}
```
# 10.42
```
#include<bits/stdc++.h>
using namespace std;

void elimDups(list<string> &words){
	words.sort();
	words.unique();
}

int main(){
	list<string> words={"sadf","aefaef","aewf","dvfhy","aa","aa"};
	elimDups(words);
	for(auto it=words.begin();it!=words.end();it++) cout<<*it<<endl;
	return 0;
}
```
# 11.12
```
#include<bits/stdc++.h>
using namespace std;

int main(){
	vector<pair<string,int>> vec(10);
	string str;
	int a;
	for(int i=0;i<10;i++){
		cin>>str>>a;
		vec[i].first=str;
		vec[i].second=a;
	}
	cout<<"vec中的元素有："<<endl;
	for(auto it=vec.begin();it!=vec.end();++it) cout<<it->first<<' '<<it->second<<endl;
	return 0;
}
```
# 11.17
	(1)合法
	(2)不合法，set中没有push_back
	(3)合法
	(4)合法
# 11.38
(1)
```
#include<bits/stdc++.h>
using namespace std;

int main(){
	unordered_map<string,size_t> word_count;
	string word;
	while(cin >> word){
		++word_count[word];
	}
	for(const auto &w : word_count){
		cout<<w.first<<" occurs "<<w.second<<((w.second>1)?"times":"time")<<endl;
	}
	return 0;
} 
```
(2)
```
#include <unordered_map>
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>

using namespace std;

unordered_map<string, string> buildMap(ifstream &map_file)
{
	unordered_map<string, string> trans_map;
	string key;
	string value;
	while(map_file >> key && getline(map_file, value))
		if(value.size() > 1)
			trans_map[key] = value.substr(1);
		else
			throw runtime_error("no rule for " + key);
	return trans_map;
}

const string &transform(const string &s, const unordered_map<string, string> &m)
{
	auto map_it = m.find(s);
	if(map_it != m.cend())
		return map_it->second;
	else
		return s;
}

void word_tranform(ifstream &map_file, ifstream &input)
{
	auto trans_map = buildMap(map_file);
	string text;
	while(getline(input, text))
	{
		istringstream stream(text);
		string word;
		bool firstword = true;
		while(stream >> word)
		{
			if(firstword)
				firstword = false;
			else
				cout << " ";
			cout << transform(word, trans_map);
		}
		cout << endl;
	}
}

int main()
{
	ifstream map_file("map_file1.txt"), input("input1.txt");
	word_tranform(map_file, input);

	return 0;
}

```
# 13.12
	执行三次,分别是accum，item1与item2
# 13.46
	（1） 右值引用，函数返回值为一个临时值；
	（2） 左值引用，vi[0]属于变量；
	（3） 左值引用，r1属于变量；
	（4） 右值引用，表达式属于临时值；
# 13.49

